---
created: 2024-08-08T10:32:00 (UTC +08:00)
tags: []
source: https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec
author: Gaurav Pandvia
output:
  word_document:
    pandoc_args: ["--write=docx"]
---

# 자바스트립트 콜 스택과 이벤트 루프의 이해—가우라브 판드비아(Gaurav Pandvia)

오늘날 웹 개발자들, 혹은 우리가 원하는 명칭인 소위 프론트엔드 엔지니어라는 이들은, 브라우저 내 상호작용성의 출발점이라는 역할부터 컴퓨터 게임, 데스크톱 위젯, 크로스 플랫폼 모바일 앱 제작에 이르기까지 모든 일을 도맡으며, 이런 결과물을 어떤 DB와도 연결할 수 있도록 보통 Node.js로 서버 측 코드를 작성하기도 한다. 따라서 이를 더 효율적으로 잘 사용하려면 자바스크립트 내부에 익숙해지는 일이 중요하기에 이를 본문에서 다루고자 한다.

자바스크립트 생태계는 과거 어느 때보다 더욱 복잡하며 앞으로 이는 더욱 심화될 것이다. 최신 웹 앱을 제작하기 위해 도구를 갖추다 보면 Webpack, Babel, ESLint, Mocha, Karma 등에 압도당하기 마련이다. 뭘 써야 하며 각 도구는 무슨 일을 하는 걸까? 오늘날 웹 개발자의 노력을 완벽하게 보여주는 웹툰 하나를 찾아냈다.

![](https://miro.medium.com/v2/resize:fit:700/1*1akEKXC95jhmIudAayITPA.png)
*자바스크립트의 피로감. 자바스크립트를 배우는 느낌*

이 모두와는 별개로 자바스트립트 개발자라면 누구나 공개된 특정 프레임워크나 라이브러리를 파고 들기에 앞서, 근본적인 차원에서 이 모든 일이 내부적으로 어떻게 가능한지 기본 토대를 먼저 알아야 할 필요가 있다.
 JS 개발자 대부분이 크롬의 런타임인 V8이라는 용어를 들어봤겠지만 정확한 의미는 무엇이며 무슨 일을 하는지 모를 수도 있다. 내가 개발자를 직업으로 삼은 첫 한 해 동안은 작업을 완료하는 일이 우선이라 이런 멋들어진 용어들을 많이 알지 못했다. 당연히 자바스크립트가 대체 어떻게 이 모든 일을 처리하는지 알고자 하는 호기심도 채울 수 없었다. 더 자세히 파고들기로 결심한 뒤 구글을 뒤적이면서 [필립 로버츠(Philip Roberts)](https://twitter.com/philip_roberts), [JSConf에서 이벤트 루프를 다룬 멋진 강연](https://www.youtube.com/watch?v=8aGhZQkoFbQ)을 포함해 여러 유익한 여러 블로그 게시물을 만나게 되면서 내가 배운 내용을 요약해 공유기로 결심했다. 알아야 할 내용이 많아 글을 두 부분으로 나누었다. 여기서는 일반적으로 사용하는 용어를 소개하며 후반부는 앞의 용어가 어떻게 모두 연결되는지를 소개한다.

자바스크립트는 스레드가 하나(single thread)이고 병행 처리가 하나인(single concurrent) 언어이며, 이는 한 번에 작업 하나, 혹은 코드 한 줄만을 다룰 수 있음을 의미한다. 하나의 **콜 스택(call stack)**을 가지며 힙(heap), 대기열(que) 등의 다른 부분과 나란히 (V8 내부에 구현한) 자바스크립트 병행 모델(JavaScript Concurrency Model)을 구성한다. 우선 각 용어를 살펴보도록 하자.

![](https://miro.medium.com/v2/resize:fit:299/1*ZSFHnq9iMHIApVLcgwczPQ.png)
*시각적으로 표현한 JS 모델([출처](https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop))*

**1.콜 스택(call stack):-** 자료 구조로서 함수 호출을 기록하며, 기본적으로 프로그램에서 우리의 현재 위치이다. 실행할 함수를 호출하면 스택에 무언가를 입력(push)하고, 함수에서 되돌아갈 때 앞서 입력한 바를 스택 최상단에서 꺼내어 출력(pop off)한다.

![](https://miro.medium.com/v2/resize:fit:600/1*E3zTWtEOiDWw7d0n7Vp-mA.gif)
*JS 스택 시각화 (GIF) (결과 오류, 100으로 정정함)*

파일이 동작하기 시작하면 먼저 모든 실행의 출발점인 진입점 함수(main function)를 찾는다. 위에서는 **console.log(bar(6))**가 스택에 입력되며 시작하고, 인수와 함께 그 위로 올라가는 함수 **bar**는 순서에 따라 함수 **foo**를 호출하고 다시 함수 foo가 스택 가장 위로 올라가면 바로 반환되어 스택에서 출력되며(pop out), 마찬가지로 bar가 바로 출력(pop out)되고 마침내 콘솔 구문을 출력하며 결과를 표시한다. 이 모두가 매 번 순식간(천분의 일 초 단위로)에 일어난다.

빨간 색으로 된 장문의 스택 트레이스 에러를 브라우저 콘솔에서 한번쯤은 본 적이 있을 텐데, 이는 기본적으로 콜 스택의 현재 상태와 어떤 함수에서 오류가 발생했는지를 위에서부터 아래 방향으로 모두 표시한다(아래 그림 참조).

![](https://miro.medium.com/v2/resize:fit:700/1*JctnBGRAYmQQPeMsgXUi0A.png)
*스택 트레이스 오류([출처](https://www.youtube.com/watch?v=8aGhZQkoFbQ))*

가끔 동일한 함수를 재귀적으로 여러 번 호출해 무한 반복에 빠질 때가 있는데 크롬 브라우저의 경우 스택 크기가 16,000 프레임으로 제한되어 있으며, 이를 넘어서면 사용자를 위해 애들을 중단시킨 뒤 **스택 최대값 도달 오류(아래 그림)**를 일으킨다.

![](https://miro.medium.com/v2/resize:fit:700/1*tqkykdU69DFrxi82JOWLbQ.png)
*([출처](https://www.youtube.com/watch?v=8aGhZQkoFbQ))*

**2.힙(heap)** :- 객체는 힙 영역에 할당되는데 이는 대부분이 비정형적인 메모리 영역이다. 모든 변수와 객체가 할당되는 메모리가 이곳이다.

**3.큐(queue)** :- 자바스크립트 런타임에 포함된 메시지 큐(message gueue)는 처리할 메시지 그리고 실행에 관련된 콜백 함수의 목록이다.  스택에 충분한 공간이 있을 때 메시지를 큐에서 꺼내 처리하는데 메시지는 참조 대상 함수에 대한 호출로 이루어져 있다(그리고 이런 방식으로 초기 스택 프레임을 생성한다). 스택이 다시 완전히 비면 메시지 처리를 종료한다. 기초적인 용어로는, 제공된 콜백 함수를 바탕으로 비동기적인 외부 이벤트(마우스 클릭이나 HTTP 요청에 대한에 응답 수신 등)에 상응하는 메시지를 대기열에 추가한다고 표현할 수 있다. 예를 들어 만약 사용자가 버튼을 클릭했지만 콜백 함수가 할당되지 않았다면 메시지가 대기열에 추가되지 않을 것이다.

## 이벤트 루프

JS 코드의 성능을 평가할 때 속도가 빠른가 혹은 느린가는 기본적으로 스택에 있는 함수가 결정하는데, `console.log()`는 빠를지라도 `for` 혹은 `while`로 수 천, 수 백만 행에 달하는 반복문을 실행한다면 속도가 느려지며, 스택에 상주하거나 스택을 차단하게 된다. 이를 **차단 스트립트(blocking script)**라 하는데 웹페이지 속도 인사이트에서 본 적이 있을 것이다.

네트워크 요청이 지연될 수 있으며, 이미지 요청이 지연될 수도 있지만 다행히 서버 요청은 비동기 함수인 AJAX로 처리가 가능하다. 만약 이런 네트워크 요청을 동기 함수로 처리하면 어떤 일이 생길까? 네트워크 요청을 전달받는 서버는 기본적으로 어딘가에 있는 또 다른 컴퓨터 혹은 장비이다. 그런데 컴퓨터가 응답을 늦게 되돌려 줄 수도 있다. 그 사이 사용자 입력을 요청하는(CTA, call to action) 버튼을 누르거나 또 다른 **페이지 렌더링**이 필요하다면 스택이 차단되며 아무런 일도 생기지 않는다. 루비(Ruby)처럼 멀티 스레드가 가능한 언어에서는 이를 다룰 수 있지만 자바스크립트와 같은 단일 스레드 언어는 스택에 있는 함수가 값을 반환하지 않는 이상 불가능하다. 브라우저가 아무 것도 할 수 없으니 웹페이지도 엉망이 된다. 최종사용자가 가변적인 UI를 원한다면 이는 바람직하지 않다. 이를 어떻게 처리해야 할까?

> "JS에서 동시성은 한 번에 하나야. 비동기 콜백은 빼고."

![](https://miro.medium.com/v2/resize:fit:580/1*nbXbMf8R6-iM7vzx9ezdgg.png)

가장 쉬운 해결 방법은 비동기 콜백(asynchronous callback)인데, 코드 일부를 실행하고 나중에 실행할 부분은 콜백으로 넘긴다는 말이다. 모두들 비동기 콜백을 본 적이 있는데 `$.get(),setTimeout(),setInterval(), Promises` 등을 사용하는 AJAX 요청과 같은 것들이다. Node.js는 전부 비동기 함수 실행과 관련이 있다. 모든 비동기 콜백은 바로 실행되는 게 아니라 일정 시간이 지난 뒤 실행되기 때문에 `console.log(), 수치 연산`처럼 동기 함수 스택에 바로 추가할 수 없다. 대체 어디서 어떻게 처리하는 걸까?

![](https://miro.medium.com/v2/resize:fit:700/1*QZkRG3HtuqrS3FDucnryKw.png)

위와 같은 실제 자바스크립트의 네트워크 요청을 살펴보자.

1. 요청 함수가 실행되면 `onreadystatechange` 이벤트 발생 시 실행되는 콜백을 익명 함수로 전달한다.
2. 콘솔에 “Script call done!”을 바로 출력한다.
3. 조금 기다리면 응답이 오고 콜백이 실행되며 콘솔에 본격적으로 결과를 출력한다.

응답에서 호출자를 분리하면 비동기 작업을 완료하고 콜백이 시작되기까지 기다리는 동안 자바스크립트 런타임이 다른 일을 하는 게 허용된다. `2`여기서 브라우저 API가 개입해 자체 API를 호출하는데 이는 기본적으로 브라우저가 생성한 스레드로서, DOM 이벤트, HTTP 요청, setTimeout 등의 비동기 이벤트를 다루기 위해 C++로 구현되어 있다(나는 이를 알고 난 후에야 **앵귤러(Angular)에서 이런 API 여럿을 변칙적으로 패치(monkey patch)한 Zone을 이용해** 런타임의 변화를 감지하는 방법을 이해하게 되었다).

> 브라우저의 웹 API는 브라우저가 생성한 스레드이며 DOM 이벤트, HTTP 요청, setTimeout와 같은 비동기 이벤트를 다루기 위해 C++로 구현한다.

WebAPI 스스로 스택에 실행 코드를 추가할 수는 없는데 이렇게 할 경우 코드 중간에 불규칙하게 등장하게 될 것이다. 위에서 다룬 메시지 콜백 큐에서 방법을 찾을 수 있다. `3`어떤 WebAPI든 실행을 완료한 후 이 대기열에 콜백을 추가한다. 이제 대기열에 추가된 콜백의 실행은 **이벤트 루프**가 전담하며 스택이 비었음을 확인하면 (콜백을) 스택에 추가한다`4`. 이벤트 루프의 기본 임무는 스택과 작업 대기열 양자의 관리이며 빈 스택을 확인해 대기열 가장 앞에 있는 작업을 스택에 추가한다. 각 메시지 혹은 콜백은 다른 메시지가 처리되기에 앞서 완전히 처리를 마친다.

```js
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

![](https://miro.medium.com/v2/resize:fit:700/1*-MMBHKy_ZxCrouecRqvsBg.png)
*Javascript 이벤트 루프 도해*

웹 브라우저는 언제든 이벤트가 발생하면 메시지를 추가하고 여기에 이벤트 리스너를 덧붙인다. 리스너가 없다면 해당 이벤트는 길을 잃는다. 때문에 클릭 이벤트 핸들러가 있는 요소를 클릭하면 메시지가 추가된다. 이는 다른 이벤트도 마찬가지다. 콜백 함수의 호출은 콜 스택에서 첫 프레임 역할을 하며, 자바스크립트가 단일 스레드이기에 모든 호출이 스택에서 반환되기를 기다리는 동안 더 이상의 메시지 폴링 및 처리는 중단된다. 뒤따르는 (비동기) 함수 호출이 스택에 새로운 호출 프레임을 추가한다.

다음 편에서는 위 절차대로 실행되는 코드를 보여주는 애니메이션과 함께, 작업이나 마이크로태스크와 같이 서로 다른 비동기 함수에 어떤 유형이 있으며 큐에서 누가 우선 순위를 갖는지 자세히 설명한다. 일부 함수 실행에서 사용하는 무지연(zero delay) 기법도 포함한다.

마음에 들었길 바라며 개선을 위해 망설이지 말고 여러분의 소중한 의견을 남겨주기 바란다.
