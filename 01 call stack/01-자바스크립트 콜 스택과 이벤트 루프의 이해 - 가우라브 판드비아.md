---
created: 2024-08-08T10:32:00 (UTC +08:00)
tags: []
source: https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec
author: Gaurav Pandvia
output:
  word_document:
    pandoc_args: ["--write=docx"]
---

# 자바스트립트 콜 스택과 이벤트 루프의 이해—가우라브 판드비아(Gaurav Pandvia)

오늘날의 웹 개발자들, 혹은 우리가 선호하는 이름인 프론트엔드 엔지니어들은, 브라우저 속 상호작용성의 출발점이라는 역할부터 컴퓨터 게임, 데스크톱 위젯, 크로스 플랫폼 모바일 앱 제작에 이르기까지 모든 업무를 도맡는다. 혹은 이런 업무가 어느 DB에나 연결 가능하도록 서버 측 코드를 (주로 Node.js로) 작성하기에 스크립트 언어로서는 거의 어디서나 볼 수 있는 수준에 다다르고 있다. 따라서 이를 더욱 효율적으로 잘 사용하려면 자바스크립트 내부에 익숙해지는 일이 중요하기에 이를 본문에서 다루고자 한다.

자바스크립트 생태계는 과거 어느 때보다 더욱 복잡하며 앞으로 이는 더욱 심화될 것이다. 최신 웹 앱을 제작하기 위해 도구를 갖추다 보면 Webpack, Babel, ESLint, Mocha, Karma 등에 압도당하기 마련이다. 뭘 써야 하며 각 도구는 무슨 일을 하는 걸까? 오늘날 웹 개발자의 노력을 완벽하게 보여주는 웹툰 하나를 찾아냈다.

![](https://miro.medium.com/v2/resize:fit:700/1*1akEKXC95jhmIudAayITPA.png)

*자바스크립트의 피로감. 자바스크립트를 배우는 느낌*

이와는 완전히 별개로 자바스크립트 개발자라면 누구나 공개된 특정 프레임워크 혹은 라이브러리를 파헤치기 전에 근원적인 수준에서 이 모두를 가능하게 하는 기본 토대를 알아야 한다. JS 개발자 대부분이 크롬의 런타임인 V8이라는 용어를 들어봤겠지만 정확한 의미가 무엇이며 무슨 일을 하는지 모를 수도 있다. 내가 개발자를 직업으로 삼은 첫 한 해 동안은 작업을 완료하는 일이 우선이라 이런 멋들어진 용어들을 많이 알지 못했다. 당연히 자바스크립트가 대체 어떻게 이 모든 일을 처리하는지 알고자 하는 호기심도 채울 수 없었다. 이를 더 깊이 파고들기로 마음을 먹고 구글을 뒤적이면서 [필립 로버츠(Philip Roberts)](https://twitter.com/philip_roberts)와 [JSConf에서 이벤트 루프를 다룬 멋진 강연](https://www.youtube.com/watch?v=8aGhZQkoFbQ)을 비롯해 여러 유익한 블로그 게시물을 만나게 되면서 나 또한 내가 배운 내용을 요약해 공유하겠다고 결심했다. 알아야 할 내용이 많아 글을 두 부분으로 나누었다. 여기서는 일반적으로 사용하는 용어를 소개하며 다음 부분에서는 앞의 용어가 어떻게 모두 연결되는지를 소개한다.

자바스크립트는 스레드가 하나인 단일 병행 언어인데, 이는 한 번에 작업 하나, 혹은 코드 한 줄만을 다룰 수 있음을 의미한다. **콜 스택(call stack)**은 한 개가 있으며 힙(heap), 큐(queue)[^1] 등의 다른 요소와 함께 (V8 내부에 구현한) 자바스크립트 병행 모델(JavaScript Concurrency Model)을 구성한다. 우선 각 용어를 살펴보도록 하자.

![](https://miro.medium.com/v2/resize:fit:299/1*ZSFHnq9iMHIApVLcgwczPQ.png)

*시각적으로 표현한 JS 모델([출처](https://developer.mozilla.org/en/docs/Web/JavaScript/EventLoop))*

**1.콜 스택(call stack):-** 자료 구조로서 함수 호출을 기록하며, 기본적으로 프로그램에서 우리의 현재 위치이다. 실행할 함수를 호출하면 스택에 무언가를 입력(push)하고, 함수에서 되돌아갈 때 앞서 입력한 바를 스택 최상단에서 꺼내어 출력(pop off)한다.

![](https://miro.medium.com/v2/resize:fit:600/1*E3zTWtEOiDWw7d0n7Vp-mA.gif)

*JS 스택 시각화 (GIF) (결과 오류, 100으로 정정함)*

파일이 동작하기 시작하면 먼저 모든 실행의 출발점인 진입 함수(main function)를 찾는다. 위에서는 **console.log(bar(6))**가 스택에 입력되며 시작한다. 다음 프레임에서 인수와 함께 그 위로 올라가는 함수 **bar**는 순서에 따라 함수 **foo**를 호출한다. 다시 함수 foo가 스택 가장 위로 올라가면 바로 반환되어 스택에서 출력되며(pop out), 마찬가지로 bar가 바로 출력(pop out)되고 마침내 콘솔 구문을 출력하며 결과를 표시한다. 이 모두가 매 번 (천분의 일 초 단위로) 순식간에 일어난다.

빨간 색으로 된 장문의 스택 트레이스 에러를 브라우저 콘솔에서 한번쯤은 본 적이 있을 텐데, 이는 기본적으로 위에서부터 아래 방향으로 콜 스택의 현재 상태와 어떤 함수에서 오류가 발생했는지를 모두 표시한다(아래 그림 참조).

![](https://miro.medium.com/v2/resize:fit:700/1*JctnBGRAYmQQPeMsgXUi0A.png)

*스택 트레이스 오류([출처](https://www.youtube.com/watch?v=8aGhZQkoFbQ))*

가끔 동일한 함수를 재귀적으로 여러 번 호출해 무한 반복에 빠질 때가 있는데 크롬 브라우저의 경우 스택 크기가 16,000 프레임으로 제한되어 있으며, 이를 넘어서면 사용자를 위해 이들을 중단시킨 뒤 **스택 최대값 도달 오류(아래 그림)**를 일으킨다.

![](https://miro.medium.com/v2/resize:fit:700/1*tqkykdU69DFrxi82JOWLbQ.png)

*([출처](https://www.youtube.com/watch?v=8aGhZQkoFbQ))*

**2.힙(heap)** :- 객체는 힙 영역에 할당되는데 이는 대부분이 비정형적인 메모리 영역이다. 모든 변수와 객체가 할당되는 메모리가 이곳이다.

**3.큐(queue)** :- 자바스크립트 런타임에 포함된 메시지 큐(message queue)는 처리할 메시지 그리고 실행에 관련된 콜백 함수의 목록이다.  스택에 충분한 공간이 있을 때 메시지를 큐에서 꺼내 처리하는데 메시지는 참조 대상 함수에 대한 호출로 이루어져 있다(그리고 이런 방식으로 초기 스택 프레임을 생성한다). 스택이 다시 완전히 비면 메시지 처리를 종료한다. 기초적인 용어로 표현하자면, 제공된 콜백 함수를 바탕으로 비동기적인 외부 이벤트(마우스 클릭이나 HTTP 요청에 대한에 응답 수신 등)에 상응하는 메시지를 대기열에 추가한다고 할 수 있다. 예를 들어 사용자가 버튼을 클릭한다 해도 콜백 함수가 할당되지 않았다면 메시지가 큐에 추가되지 않을 것이다.

## 이벤트 루프

JS 코드의 성능을 평가할 때 속도가 빠른지 혹은 느린지는 기본적으로 스택에 있는 함수가 결정하는데, `console.log()`는 빠르겠지만 `for` 혹은 `while`로 수 천, 수 백만 행에 달하는 반복문을 실행한다면 느려지며, 스택을 점유하거나 차단하게 된다. 이를 **차단 스트립트(blocking script)**라 하는데 웹페이지 속도 인사이트에서 본 적이 있을 것이다.

네트워크 요청이 지연될 때도 있고 이미지 요청이 지연될 수도 있지만 다행히 서버 요청은 비동기 함수인 AJAX로 처리가 가능하다. 만약 이런 네트워크 요청을 동기 함수로 처리하면 어떤 일이 생길까? 네트워크 요청을 전달받는 서버는 기본적으로 어딘가에 있는 또 다른 컴퓨터 혹은 장비이다. 그런데 컴퓨터에서 돌아오는 응답이 늦어질 수 있다. 만약 이 사이에 사용자 입력을 요청하는(CTA, call to action) 버튼을 누르거나 또 다른 **페이지 렌더링**이 필요하다면 스택이 차단되며 아무런 일도 일어나지 않는다. 루비(Ruby)처럼 멀티 스레드가 가능한 언어는 이를 다룰 수 있지만 자바스크립트와 같은 단일 스레드 언어는 스택에 있는 함수가 값을 반환하지 않는 이상 불가능하다. 브라우저가 아무 것도 할 수 없으니 웹페이지도 엉망이 된다. 가변적인 사용자 UI를 원한다면 바람직 하지 않은 일이다. 어떻게 처리해야 할까?

> "JS에서 동시성은 한 번에 하나야. 비동기 콜백은 빼고."

![](https://miro.medium.com/v2/resize:fit:580/1*nbXbMf8R6-iM7vzx9ezdgg.png)

가장 쉬운 해결 방법은 비동기 콜백(asynchronous callback)인데, 코드 일부를 실행하고 나중에 실행할 부분은 콜백에 넘겨준다는 말이다. 모두들 비동기 콜백을 본 적이 있는데 `$.get(),setTimeout(),setInterval(), Promises` 등을 사용하는 AJAX 요청과 같은 것들이다. Node.js는 전부 비동기 함수 실행과 관련이 있다. 모든 비동기 콜백은 바로 실행되는 게 아니라 일정 시간이 지난 후 실행되기 때문에 `console.log(), 수치 연산`같은 동기 함수(synchronous function)처럼 스택에 바로 추가하기가 불가능하다. 대체 어디서 어떻게 처리하는 걸까?

![](https://miro.medium.com/v2/resize:fit:700/1*QZkRG3HtuqrS3FDucnryKw.png)

위와 같은 실제 자바스크립트의 네트워크 요청을 살펴보자.

1. 요청 함수가 실행되면 `onreadystatechange` 이벤트 발생 시 실행되는 콜백을 익명 함수로 전달한다.
2. 콘솔에 “Script call done!”을 바로 출력한다.
3. 조금 기다리면 응답이 오고 콜백이 실행되며 콘솔에 본격적으로 결과를 출력한다.

응답에서 호출자를 분리하면 비동기 작업을 완료하고 콜백이 시작되기까지 기다리는 동안 자바스크립트 런타임이 다른 일을 하는 게 허용된다. `2`여기서 브라우저 API가 개입해 자체 API를 호출한다. 기본적으로는 브라우저가 생성한 스레드로서, DOM 이벤트, HTTP 요청, setTimeout 등의 비동기 이벤트를 다루기 위해 C++로 구현되어 있다(나는 이를 알고 난 후에야 **앵귤러(Angular)에서 이런 API 여럿을 변칙적으로 패치(monkey patch)한 Zone을 이용해** 런타임의 변화를 감지하는 방법을 이해하게 되었다).[^2]

> 브라우저의 웹 API는 브라우저가 생성한 스레드이며 DOM 이벤트, HTTP 요청, setTimeout와 같은 비동기 이벤트를 다루기 위해 C++로 구현한다.

WebAPI 스스로 스택에 실행 코드를 추가할 수는 없는데 이럴 경우 코드 중간에 (실행 코드가) 불규칙적으로 등장하게 된다. 방법은 위에서 다룬 메시지 콜백 큐이다. `3`어떤 WebAPI든 실행을 마친 후 콜백을 큐에 추가한다. 큐에 추가된 콜백의 실행은 이제 **이벤트 루프**가 담당하며 스택이 비어 있음을 확인한 후 (콜백을) 스택에 추가한다`4`. 이벤트 루프의 기본 임무는 스택과 작업 모두를 관리하는 일로서 빈 스택을 확인해 큐 가장 앞에 있는 작업을 스택에 추가한다. 각 메시지 혹은 콜백은 다른 메시지가 처리되기에 앞서 완전히 처리를 마친다.

```js
while (queue.waitForMessage()) {
  queue.processNextMessage();
}
```

![](https://miro.medium.com/v2/resize:fit:700/1*-MMBHKy_ZxCrouecRqvsBg.png)

*Javascript 이벤트 루프 도해*

웹 브라우저는 언제든 이벤트가 발생하면 메시지를 추가하고 여기에 이벤트 리스너를 덧붙인다. 리스너가 없다면 해당 이벤트는 길을 잃는다. 때문에 클릭 이벤트 핸들러가 있는 요소를 클릭하면 메시지가 추가된다. 이는 다른 이벤트도 마찬가지다. 콜백 함수를 호출하면 콜 스택에서 첫 프레임이 되며, 자바스크립트가 하나의 스레드만 가지므로 모든 호출이 스택에서 반환되기를 기다리는 동안 더 이상의 메시지 폴링[^3] 및 처리는 중단된다. 뒤따르는 (비동기) 함수 호출이 스택에 새로운 호출 프레임을 추가한다.

다음 편에서는 위 절차대로 실행되는 코드를 보여주는 애니메이션과 함께, 작업이나 마이크로태스크와 같이 서로 다른 비동기 함수에 어떤 유형이 있으며 큐에서 누가 우선 순위를 갖는지 자세히 설명한다. 일부 함수 실행에서 사용하는 무지연(zero delay) 기법도 포함한다.

만족스러웠길 바라며 편한 마음으로 여러분의 소중한 의견을 남겨 준다면 개선에 도움이 될 것이다.

### 주석

[^1]: 자료구조로서 큐를 설명하는 페이지는 다음과 같다. 이 글에서는 일단 선입선출을 따르는 '대기열'로 이해하면 무리가 없다.
[^2]: 원문에는 Angular 2로 적었으나 구글에서 바꾼 이름을 따라 Angular로 번역한다. monkey patch는 변칙적인 패치로서 [위키피디아의 설명](https://ko.wikipedia.org/wiki/%EB%AA%BD%ED%82%A4_%ED%8C%A8%EC%B9%98)을 참조하라. 일반적으로 권장되지 않는 방법임에 유의할 것.
[^3]: 폴링은 [정보통신용어사전의 설명](http://word.tta.or.kr/mobile/dictionaryView.do?word_seq=052425-1)을 참고하라.
